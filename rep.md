# Project1 
*__邬涵博 徐昊天 刘镇__*

## 概述与分工

Project1要求我们实现简单向量计算语句到C++语言的翻译。为了方便项目的分工和并行，我们将全部工作分为 __语法解析__、__IR构建__、__代码生成__ 三个部分，分别用来词法语法分析、构建IR树、生成C++代码。具体分工如下：

邬涵博：语法解析主体、IR构建部分、代码生成

徐昊天：IR构建主体、代码生成

刘镇：语法解析部分、测试

github：https://github.com/EverNebula/CompilerProject-2020Spring


## 语法解析
由于给定的语法简单而有规律，我们使用语法规律人工实现了一个简单的解析器。在程序使用`jsoncpp`读入源json文件后，会首先去掉语句所有的空格，并将占两个字符的`//`运算符替换为`$`方便处理。处理过后的语句将会被送入解析器的入口`Parse_P`函数进行词法语法分析。

具体的解析过程详见`project1/solution/parser.h`以及`project1/solution/parser.cc`文件。

## IR构建

### 构造IR树

为了方便，IR抽象语法树的构建其实是与解析同步进行的，解析每个非终结符号或终结符号都会建立对应节点并返回相应的Expr，下层节点返回相应Expr后，上层节点就可以对应建立节点并继续返回Expr，想当于整棵语法树以后序遍历的顺序构造节点实例，最后得到Kernel节点。

### 更新Index边界

全局记录一个Index的Vector，记作index\_list，每次遇到Index，若不在index\_list里则插入，若在，则根据Index对应的范围(<>)和Index的表达式解出新的范围，并根据缩小范围的原则进行更新，最终得到的index\_list里的全部为正确范围，最后根据其生成for循环部分。

该部分代码也在`project1/solution/parser.h`以及`project1/solution/parser.cc`文件中。

## 代码生成

生成C++代码我们主要依靠提供的`IRPrinter`模板，由于只需要改成C++语法，比较简单，就不过多赘述。需要注意的是在输出`Binary`二元运算时，要注意为高优先级运算符的表达式加上括号保证顺序正确。具体输出方式详见`src/IRPrinter.cc`文件。

当然我们不能只更改输出，为了满足C++的语法，我们需要为原语句增加循环、临时变量等。

### 函数签名

记录每个变量名称及其范围，生成签名时根据json字符串里的输入输出确定变量顺序。

### 语句拆分

```
A<2>[i] = B<2>[j] + C<2>[k]
```

上面的语句显然是要拆分成两个部分，`j`与`k`分别循环，而不是嵌套循环，那会使每个数被多加一次。因此我们需要在第一个`RHS`中根据加减号拆成多个部分分别计算。一个部分的子循环只包括表达式中存在的下标，比如`B<2>[j]`就只能对`j`进行循环而不对`k`进行循环。

### 临时变量

```
A<2, 2>[i, j] = A<2, 2>[j, i]
```

矩阵转置是一个需要临时变量的典型例子。我们的处理方式是对于每一个语句，都拆成三部分：`temp = 0`、`calc`、`LHS = temp`。其中不同语句的`temp`需要有不同定义，因为`LHS`的`shape`可能不同。
