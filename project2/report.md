# Project2
*__邬涵博 徐昊天 刘镇__*

## 概述与分工

Project2要求我们在之前的基础上实现C++语言的自动求导器。为了方便项目的分工和并行，我们将全部工作分为 __语法解析__、__IR构建__、__代码生成__ 三个部分，分别用来词法语法分析、构建IR树、生成C++代码。这样分工的依据详见下面的问题分析。具体分工如下：

邬涵博：因子替换、Index转换

徐昊天：

刘镇：

github：https://github.com/EverNebula/CompilerProject-2020Spring


## 问题分析

因为对于向量求导不甚了解，我们小组选择首先对所有的case进行一个概览，并将其中需要实现的功能以及难点总结出来，方便代码的编写和分工。

- 因子左右替换(common) `A=B*C => dB=dA*C`

- 消除常数项(case 1)

- 多变量求导(case 4)

- 语句拆分(case 10)

- index转换(case 6,8,10)

针对上述五个问题，由于需要多道pass，我们最终决定拆分为两个Mutator来解决，第一个Mutator为__DerivMutator__，用来处理前三个问题；第二个Mutator为__IndexMutator__，它们都位于`project2/solution/derivmutator.cc`中。代码的输出则依旧使用之前所编写的IRPrinter。下面将对于这两个Mutator的结构及实现作介绍。

## DerivMutator

### 问题及解决1 (例如签名)

描述。要有例子。


## IndexMutator

### 效果

尽管DerivMutator输出的结果已经可以正确得到答案，但是对于赋值语句左边的Index会存在计算，这对于时间局部性是很不友好的。因此有了IndexMutator再次对AST遍历，解决最后的index转换问题。

```
  for (int k = 0; k < 8; ++k) {
    for (int n = 0; n < 2; ++n) {
      for (int p = 0; p < 5; ++p) {
        for (int q = 0; q < 5; ++q) {
          for (int c = 0; c < 16; ++c) {
            for (int r = 0; r < 3; ++r) {
              for (int s = 0; s < 3; ++s) {
                dB[n][c][p + r][q + s] += (dA[n][k][p][q]) * (C[k][c][r][s]);
              }
            }
          }
        }
      }
    }
  }
```

上面是DerivMutator输出的结果，而经过IndexMutator，它将会变为：

```
  for (int k = 0; k < 8; ++k) {
    for (int n = 0; n < 2; ++n) {
      for (int p = 0; p < 5; ++p) {
        for (int q = 0; q < 5; ++q) {
          for (int c = 0; c < 16; ++c) {
            for (int dB2 = 0; dB2 < 7; ++dB2) {
              for (int dB3 = 0; dB3 < 7; ++dB3) {
                if (((dB2 - p >= 0) && (dB2 - p < 3)) && ((dB3 - q >= 0) && (dB3 - q < 3))) {
                  dB[n][c][dB2][dB3] += (dA[n][k][p][q]) * (C[k][c][dB2 - p][dB3 - q]);
                }
              }
            }
          }
        }
      }
    }
  }
```

可以发现，它用`dB2,dB3`代替了原来的`r,s`，消除了左边下标的计算。同时对应下表的变换，加入了If语句来防止数组访问越界。

### 牺牲Index

我们目的是消除左值向量下标计算，对于这些存在计算的下标。所以我们的思路是，对于每一维，寻找参与下标计算的一个Index作为牺牲者，将这一维用一个新的Index来替换。比如对于`dB[n][c][p+r][q+s]`中，存在两个维度有下标计算，因此我们定义两个新Index，分别为`dB2=p+r`，`dB3=q+s`。通过这两个式子我们可以反推出`r=dB2-p`，`s=dB3-q`。

`r`与`s`的反推我们使用如下的方法。为了更加具体地介绍，下面的例子为通过`a=b+c*4`反推`c=(a-b)/4`。`b+c*4`的AST需要进行的变换如下：

```
  +               / 
 / \             / \
b   *     =>    -   4
   / \         / \
  c   4       a   b
```

我们通过栈记录下从根到牺牲节点c的一条路径，并同时记录下另一边节点的值，栈中信息为[$, (*, 4), (+, b)]。可以发现，变换后的AST其实就是按 __栈的顺序__ 使用 __逆运算__ 构建而成。根据栈信息，在`Var`中一次性构建AST即可。

记录下这个牺牲Index的计算表达式后，将它存入Map `replaceExpr`中，之后在右值中访问到这个Index时直接替换为计算后的Expr。

### 取模的处理

在case 8中，出现了对于下标取模的处理，`flatten`等函数中才能使它有意义，在这里我们默认出现取模就是发生了shape的改变。因此如果出现式子`x=Expr mod k`，会直接取处理`Expr`而先忽略`k`。比如case 8的`dA[i/16][i%16]`，我们要将其变为`dA[dA0][dA1]`，计算`i`与`dA1`的关系时，发现`i=dA1 mod k`，因此加在之前`i`的计算Expr之后。

由于shape发生改变，LoopNest中也要检查并加上所有的新Index。

### 边界条件

下标发生了变换，需要额外的边界检查，比如case 10中同时有`i`,`i+1`,`i+2`，如果粗暴地转换为`dB`,`dB-1`,`dB-2`，而外层循环还是从0-10，就会发生数组越界。

解决方法是如果右值中出现了一个牺牲Index，原范围为[a,b]，那么就在这个Move外套一个If语句，条件为`Expr>=a && Expr<=b`，`Expr`为之前得到的计算表达式。

## 实验结果

实验代码在Mac OSX操作系统上，编译器为clang-1100.0.33.17。

case 10是一个比较全面的例子，下面给出case 10在不同阶段的代码：
```

```

测试点全部通过：

[fig]

## 具体例子解释

可以见上面针对各个情况的解决方案中举出的各个例子。

## 总结

在整个Project中，我们活用一学期学习的编译知识，搭建了一个简易可行的自动求导器。具体涉及知识点如下：

- 词法分析：

- 语法分析：



